<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Rubik's Cube</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --size: min(70vmin, 420px); }
    .scene { perspective: 1200px; }
    .cube {
      width: var(--size);
      height: var(--size);
      transform-style: preserve-3d;
      touch-action: none;
      will-change: transform;
    }
    .face {
      position: absolute;
      width: var(--size);
      height: var(--size);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 2px;
      backface-visibility: hidden;
    }
    .sticker {
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,.2);
    }
  </style>
</head>
<body class="bg-slate-900 text-white min-h-screen flex flex-col items-center">
  <header class="w-full max-w-4xl px-4 py-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
    <div class="flex items-center gap-3">
      <div class="text-xl font-semibold">Rubik’s Cube</div>
      <div id="status" class="text-sm text-slate-300">Mode: Free</div>
    </div>
    <div class="flex flex-wrap gap-2">
      <button id="playBtn" class="px-3 py-2 bg-emerald-500 text-white rounded-lg">Play Mode</button>
      <button id="freeBtn" class="px-3 py-2 bg-slate-700 rounded-lg">Free Mode</button>
      <button id="scrambleBtn" class="px-3 py-2 bg-indigo-500 rounded-lg">Scramble</button>
      <button id="resetBtn" class="px-3 py-2 bg-slate-700 rounded-lg">Reset</button>
    </div>
  </header>

  <main class="flex-1 w-full max-w-4xl px-4 pb-8 flex flex-col items-center gap-4">
    <div class="w-full flex justify-between items-center text-slate-300 text-sm">
      <div>Drag to rotate cube. Tap a sticker to turn its face.</div>
      <div id="timer">00:00</div>
    </div>

    <div class="w-full flex items-center gap-3 text-sm text-slate-300">
      <span>Zoom</span>
      <input id="zoomSlider" type="range" min="40" max="110" value="70" class="w-full" />
      <span id="zoomLabel">70%</span>
    </div>

    <div class="scene w-full flex justify-center">
      <div id="cube" class="cube"></div>
    </div>

    <div class="text-slate-400 text-xs max-w-2xl">
      Tip: Tap a facelet to rotate clockwise. Long‑press for counter‑clockwise.
    </div>
  </main>

  <script>
    const colors = {
      U: "#f8fafc", // white
      D: "#f97316", // orange
      F: "#22c55e", // green
      B: "#3b82f6", // blue
      L: "#ef4444", // red
      R: "#eab308"  // yellow
    };

    const solvedState = () => ({
      U: Array(9).fill("U"),
      D: Array(9).fill("D"),
      F: Array(9).fill("F"),
      B: Array(9).fill("B"),
      L: Array(9).fill("L"),
      R: Array(9).fill("R")
    });

    let state = solvedState();
    let mode = "free";
    let timerId = null;
    let startTime = null;

    const cubeEl = document.getElementById("cube");
    const statusEl = document.getElementById("status");
    const timerEl = document.getElementById("timer");
    const zoomSlider = document.getElementById("zoomSlider");
    const zoomLabel = document.getElementById("zoomLabel");

    const faces = ["F","B","U","D","L","R"];

    function render() {
      cubeEl.innerHTML = "";
      for (const face of faces) {
        const faceEl = document.createElement("div");
        faceEl.className = "face";
        faceEl.dataset.face = face;

        const size = "calc(var(--size) / 2)";
        const transforms = {
          F: `translateZ(${size})`,
          B: `rotateY(180deg) translateZ(${size})`,
          U: `rotateX(90deg) translateZ(${size})`,
          D: `rotateX(-90deg) translateZ(${size})`,
          L: `rotateY(-90deg) translateZ(${size})`,
          R: `rotateY(90deg) translateZ(${size})`
        };
        faceEl.style.transform = transforms[face];

        state[face].forEach((c, i) => {
          const sticker = document.createElement("div");
          sticker.className = "sticker";
          sticker.style.background = colors[c];
          sticker.dataset.face = face;
          sticker.dataset.index = i;
          faceEl.appendChild(sticker);
        });

        cubeEl.appendChild(faceEl);
      }
    }

    function rotateFaceCW(face) {
      const f = state[face].slice();
      state[face] = [
        f[6], f[3], f[0],
        f[7], f[4], f[1],
        f[8], f[5], f[2]
      ];
    }

    function rotateFaceCCW(face) {
      const f = state[face].slice();
      state[face] = [
        f[2], f[5], f[8],
        f[1], f[4], f[7],
        f[0], f[3], f[6]
      ];
    }

    function turn(face, clockwise = true) {
      const s = state;
      const t = JSON.parse(JSON.stringify(s));

      const map = {
        F: [["U",[6,7,8]], ["R",[0,3,6]], ["D",[2,1,0]], ["L",[8,5,2]]],
        B: [["U",[2,1,0]], ["L",[0,3,6]], ["D",[6,7,8]], ["R",[8,5,2]]],
        U: [["B",[0,1,2]], ["R",[0,1,2]], ["F",[0,1,2]], ["L",[0,1,2]]],
        D: [["F",[6,7,8]], ["R",[6,7,8]], ["B",[6,7,8]], ["L",[6,7,8]]],
        L: [["U",[0,3,6]], ["F",[0,3,6]], ["D",[0,3,6]], ["B",[8,5,2]]],
        R: [["U",[8,5,2]], ["B",[0,3,6]], ["D",[8,5,2]], ["F",[8,5,2]]]
      };

      if (clockwise) rotateFaceCW(face); else rotateFaceCCW(face);

      const order = map[face];
      const seq = clockwise ? [3,0,1,2] : [1,2,3,0];

      for (let i = 0; i < 4; i++) {
        const [fromFace, fromIdx] = order[seq[i]];
        const [toFace, toIdx] = order[i];
        toIdx.forEach((ti, k) => s[toFace][ti] = t[fromFace][fromIdx[k]]);
      }
    }

    function scramble(n = 20) {
      const moves = ["F","B","U","D","L","R"];
      for (let i = 0; i < n; i++) {
        const face = moves[Math.floor(Math.random() * moves.length)];
        const cw = Math.random() > 0.5;
        turn(face, cw);
      }
      render();
    }

    function setMode(m) {
      mode = m;
      statusEl.textContent = `Mode: ${m === "play" ? "Play" : "Free"}`;
      if (m === "play") startTimer(); else stopTimer(true);
    }

    function startTimer() {
      if (timerId) return;
      startTime = Date.now();
      timerId = setInterval(() => {
        const ms = Date.now() - startTime;
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const ss = (s % 60).toString().padStart(2, "0");
        timerEl.textContent = `${m.toString().padStart(2, "0")}:${ss}`;
      }, 250);
    }

    function stopTimer(reset = false) {
      clearInterval(timerId);
      timerId = null;
      if (reset) timerEl.textContent = "00:00";
    }

    // Smooth drag + inertia
    let isDragging = false;
    let lastX = 0, lastY = 0;
    let rotX = -25, rotY = 35;
    let velX = 0, velY = 0;

    function updateCubeTransform() {
      cubeEl.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
    }

    function animate() {
      // inertia
      if (!isDragging) {
        rotY += velX;
        rotX += velY;
        velX *= 0.92;
        velY *= 0.92;
        if (Math.abs(velX) < 0.001) velX = 0;
        if (Math.abs(velY) < 0.001) velY = 0;
      }
      updateCubeTransform();
      requestAnimationFrame(animate);
    }
    animate();

    cubeEl.addEventListener("pointerdown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      cubeEl.setPointerCapture(e.pointerId);
    });

    cubeEl.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;

      // FIXED: natural direction (move right -> cube rotates right)
      rotY += dx * 0.4;
      rotX -= dy * 0.4;

      // velocity for inertia
      velX = dx * 0.02;
      velY = -dy * 0.02;

      lastX = e.clientX;
      lastY = e.clientY;
    });

    cubeEl.addEventListener("pointerup", () => { isDragging = false; });
    cubeEl.addEventListener("pointercancel", () => { isDragging = false; });

    // tap to turn face
    let pressTimer = null;
    cubeEl.addEventListener("pointerdown", (e) => {
      if (!e.target.classList.contains("sticker")) return;
      pressTimer = setTimeout(() => {
        const face = e.target.dataset.face;
        turn(face, false);
        render();
        pressTimer = null;
      }, 420);
    });

    cubeEl.addEventListener("pointerup", (e) => {
      if (!e.target.classList.contains("sticker")) return;
      if (pressTimer) {
        clearTimeout(pressTimer);
        pressTimer = null;
        const face = e.target.dataset.face;
        turn(face, true);
        render();
      }
    });

    // zoom (slider + wheel)
    function setZoom(percent) {
      const p = Math.min(110, Math.max(40, percent));
      zoomSlider.value = p;
      zoomLabel.textContent = `${p}%`;
      document.documentElement.style.setProperty("--size", `min(${p}vmin, ${p * 6}px)`);
    }

    zoomSlider.addEventListener("input", (e) => setZoom(Number(e.target.value)));
    window.addEventListener("wheel", (e) => {
      if (!e.ctrlKey) return; // prevent accidental scroll zoom
      e.preventDefault();
      setZoom(Number(zoomSlider.value) + (e.deltaY > 0 ? -3 : 3));
    }, { passive: false });

    document.getElementById("scrambleBtn").addEventListener("click", () => scramble(25));
    document.getElementById("resetBtn").addEventListener("click", () => { state = solvedState(); render(); });
    document.getElementById("playBtn").addEventListener("click", () => setMode("play"));
    document.getElementById("freeBtn").addEventListener("click", () => setMode("free"));

    render();
    setZoom(70);
  </script>
</body>
</html>